<!DOCTYPE html>

<html>
  <head>
    <title>Off course alarm testing</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1">
    <style>
      #MainPage { display: grid; grid-template-columns: 33% 33% 33%; }
      #Settings { display: grid; grid-template-columns: 45% auto; }
      .setTxt { grid-column: 1 / span 2; }
      #Log { display: grid; grid-template-columns: auto; }
      #logtext { grid-column: 1 / span 3; }
      #DemoParms { display: grid; grid-template-columns: auto auto auto auto auto auto; }

/* desktop computer */
    @media only screen and (min-width: 1000px) { 
      .minorButton, .majorButton, .noHover, .minorButton2, .SetOut, legend { font-size: 16px; }
      .statusBar { font-size: 12px; }
      .outData { font-size: 28px; }
      body { max-width: 410px; }
    }
    /* my phone from git hosting */
    @media only screen and (max-width: 1000px) { 
      .majorButton, .noHover { font-size: 6vw; }
      .minorButton, .minorButton2, legend, .setOut { font-size: 4vw; }
      .statusBar { font-size: 3vw; }
      .outData { font-size: 8vw; }
    }
    
      :root { --main-text: #000080; --main-button: #4CAF50; --minor-button: #CC7A8b; --grey-button: #8cb88b;
              --main-off:  #B3B3D9; --main-run: #90EE90; --main-standby:   #FBB117; --main-alarm:   #F62817; --main-err: #FFFF00; }
      h1 { color: blue; font-size: 20px; }
      /* cannot align output object text */
      .outData { padding: 6px 16px; margin-bottom: 20px; line-height: normal;
                 color: var(--main-text); border-radius: 4px; font-weight: bold; }
      .setOut { color: var(--main-text); font-weight: bold; }
      .statusBar { color: var(--main-text); font-weight: bold; margin-left: 4px; text-align: left; }
      legend { color: var(--main-text); font-weight: bold; text-align: center; margin-top: 20px; }
      legend.settings { color: var(--main-text); font-weight: bold; text-align: left; margin-top: 20px; }
      /* legend { color: var(--main-text); font-weight: bold; text-align: center; margin-top: 20px; width: 140px; } */

        /* this is the disabled buttons */
      .noHover { padding: 12px 12px; background: var(--grey-button); color: #8f8d8a;
               font-weight: bold; margin: 10%; margin-top: 20px; width: 80%;
               border-radius: 8px; outline: 2px solid Var(--main-button); outline-offset: 0px; transition: outline-offset 200ms ease; }

      /* the real McCoy  don't specify border: none; it kills the click effect */
      .majorButton { padding: 12px 12px; background: var(--main-button); color: white;
                     font-weight: bold; margin: 10%; margin-top: 20px; width: 80%;
                     border-radius: 8px; outline: 2px solid Var(--main-button); outline-offset: 0px; transition: outline-offset 200ms ease; }
      .majorButton:hover { outline-offset: 2px; } 
      
      /* buttons on main screens */
      .minorButton { padding: 9px 10px; background: var(--minor-button); color: white;
                     font-weight: bold; margin: 10%; margin-top: 20px; width: 80%;
                     border-radius: 8px; outline: 1px solid var(--minor-button); cursor: pointer; } 
      .minorButton:hover { outline-offset: 1px; } 
                     /* for settings, its a long word */

      .minorButton2 { padding: 9px 10px; background: var(--minor-button); color: white; 
                     font-weight: bold;  margin: 10%;
                      border-radius: 8px; outline: 1px solid var(--minor-button); } 
      .minorButton2:hover { outline-offset: 1px; } 


.rowbox { display: flex; flex-direction: row; }
#testButtons > div { padding: 10px; }
#returnButtons { padding: 10px; }
#minorButtons > div { padding: 10px; }

input[type="range"] {
  width:90%;
}
/* led stuff */
.green { background-image: -webkit-linear-gradient(top, #13fB04 0%, #58e343 50%, #ADED99 100%); }
.orange { background-image: -webkit-linear-gradient(top, #f9a004 0%, #e0ac45 50%, #ead698 100%); }
.red { background-image: -webkit-linear-gradient(top, #fb1304 0%, #e35843 50%, #edad99 100%); animation: blinkRed 1.5s infinite; }

@keyframes blinkRed {
    from { background-color: #F00; }
    50% { background-color: #A00; box-shadow: rgba(0, 0, 0, 0.2) 0 -1px 7px 1px, inset #441313 0 -1px 9px, rgba(255, 0, 0, 0.5) 0 2px 0;}
    to { background-color: #F00; }
}

.led {
    border-radius: 5px;
    width: 10px;
    height: 10px;
    box-shadow: 0px 0px 3px black;
    margin: 8px;
    zoom: 0;
}

.led:after {
    display: inline;
    content: '';
    margin-left: 1px;
    margin-right: 1px;
    width: 8px;
    height: 6px;
    -webkit-border-top-right-radius: 4px 3px;
    -webkit-border-top-left-radius: 4px 3px;
    -webkit-border-bottom-right-radius: 4px 3px;
    -webkit-border-bottom-left-radius: 4px 3px;
    background-image: -webkit-linear-gradient(top, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.2) 100%);
}
    </style>

    <script type="text/javascript">

      // Sound file for audio alarm
      var audioAlarm = "illustrious.wav"
      var version = "0.10"

      var DEMO_MODE = true; // DEMO_MODE will simulate movement and reduce timer from minutes to seconds
      // for 20 min check timevar latOffset = 0.03; lonOffset = 0.03;  // vars to fake movement for testing 0.01 is ~ 0.6nm
      // for 5 min check
      var initDir = 30; initSpeed = 5.2; initDur = 50;
      var subsDir = 34; subsSpeed = 5.2; hemiSphere = "NE"
      var offsets = { accu: { latOffAcc: 0, lonOffAcc: 0, loopCount: 0, hemisp: "" },
                      init: { latOffset: 0, lonOffset: 0 },
                      subs: { latOffset: 0, lonOffset: 0 } };
      var testSet = offsets.init; 
      var loopCount = 0;
      var quadrant = 1; // adjust once bearing is known, used to determine if offsets added or subtracted 

      var dtr = Math.PI/180;
      // set these to your desired default values
      var checkTime=5, accVar=5; xteVar=200;
      var initialLoc  = { latitude: 0, longitude: 0 };
      var currentLoc  = { latitude: 0, longitude: 0 };
      var previousLoc = { latitude: 0, longitude: 0 };
      var estLoc      = { latitude: 0, longitude: 0 };
      var deltaT=0, deltaD=0, heading=0, course=0;
      var xte=0, cseError=0;

      var objectId = {};  // retrieve on start-up and reuse instead of looking up again and again
      var c = {};         // retreive on start-up from css variables
      // make this an object 
      var but = {
        reset: "ResetButton",
        run:   "RunButton",
        off:   "OffButton",
        stby:  "StbyButton"
      }
      var runStates = {
        off:     "Off  ",
        standby: "Stdby",
        run:     "Run  ",
        alarm:   "Alarm"
      } 
      var screen = {
        main: "main",
        log:  "log",
        settings: "settings"
      }
      var currentState = runStates.off;
      var checkTimerCreate = 0;
      // Alarm is a oneshot, once dismissed return to Run but may trigger again on next check
      var flashTimerCreated = false;
      var alarmBg = true;  // used for toggling alarm flash
      var audioPlaying = false;

// enough of the globals already

        // calc DEMO_MODE coordinate offsets 
        function calcOffsets()
        {
          initDir = Number( document.getElementById("initcse").value );
          initSpeed = document.getElementById("initspd").value;
          initDur = document.getElementById("initdur").value;
          subsDir = Number( document.getElementById("subscse").value ) ;
          subsSpeed = document.getElementById("subsspd").value;
          currentHemi = document.getElementById("hemisp").value;

          let drPerPeriod  = initSpeed * checkTime / 60;
          let drPerPeriod2 = subsSpeed * checkTime / 60;
          let pos1 = pos2 = { latitude: 0, longitude: 0 };
          pos2 = CalcEstPosition( pos1, drPerPeriod, initDir );
          offsets.init.latOffset = pos2.latitude;
          offsets.init.lonOffset = pos2.longitude;
          pos2 = CalcEstPosition( pos1, drPerPeriod2, subsDir );
          offsets.subs.latOffset = pos2.latitude;
          offsets.subs.lonOffset = pos2.longitude;
          offsets.accu.loopCount = initDur / checkTime;
          testSet = offsets.init;
          // FIXME += or just =, should be no previous value. are offsets ever signed? 
          offsets.accu.latOffAcc = testSet.latOffset;
          offsets.accu.lonOffAcc = testSet.lonOffset;
          console.log("DEMO  | calcOff | hemisphere: " + currentHemi + " offsets [ " 
          + offsets.init.latOffset.toFixed(4) + ", "
          + testSet.lonOffset.toFixed(4) + " ], [ "
          + offsets.subs.latOffset.toFixed(4) + ", "
          + offsets.subs.lonOffset.toFixed(4) + " ]" );
          // set hemisphere so gps loc can be tweaked to be in different hemisphere
          offsets.accu.hemisp = currentHemi;
        }

      // onload Main function
      function StartApp()
      {
        // get screen size and think about how big stuff needs to be
        alert("Offcourse Alarm v"+version+"\n"+window.innerWidth+" px wide \n"+window.innerHeight+" px high");
        document.getElementById("versionString").innerHTML ="Off-course Alarm v"+version;
        if ( !navigator.geolocation ) {
          errStr = "FATAL | StartApp | Geolocation is not supported by this browser.";
          alert( errStr ); // not going to work 
          // FIXME going to need to disable everything and just display some info
          return;
        }
        document.getElementById("MainPage").style.width = "100%"; 
        // get a bunch of object id's once so we dont do it multiple times 
        // interesting, this is a hack to reuse previously retreived Id's 
        // works ok as is but if used with backgroundColor and explicit values, flags a runtime error
        // but when used with the color table below is Ok !! go figure.
        objectId.main =  document.getElementById("MainPage");
        objectId.set  =  document.getElementById("Settings");
        objectId.log  =  document.getElementById("Log");
        objectId.demo =  document.getElementById("DemoParms");

        // get our colors from the css
        const root   = document.querySelector(':root');
        c.off   = getComputedStyle(root).getPropertyValue("--main-off");
        c.run   = getComputedStyle(root).getPropertyValue("--main-run");
        c.err   = getComputedStyle(root).getPropertyValue("--main-err");
        c.stby  = getComputedStyle(root).getPropertyValue("--main-standby");
        c.alarm = getComputedStyle(root).getPropertyValue("--main-alarm");

        // disable the reset button 
        disableButton( but.reset );
        orangeLed();
        // now the real setup
        SetupAudio();
        DisplayMain();

        // stop spewing my devt messages 
        if ( DEMO_MODE ) { 
          document.getElementById("initcse").value = initDir;
          document.getElementById("initspd").value = initSpeed;
          document.getElementById("initdur").value = initDur;
          document.getElementById("subscse").value = subsDir;
          document.getElementById("subsspd").value = subsSpeed;
          document.getElementById("hemisp").value = hemiSphere;
          objectId.demo.style.display="none";
        } else {
            objectId.demo.style.display="none";
            console.log = function(){};
        }
      }

// this function throws an exception when called from timer callback
// however the enable does not ???
// may be the add remove. If called twice then 

      function disableButton( inButton )
      {
        if ( !document.getElementById(inButton).disabled ) {
          document.getElementById(inButton).classList.remove("majorButton");
          document.getElementById(inButton).classList.add("noHover");
          document.getElementById(inButton).disabled = true;
        }
      }

      function enableButton( inButton ) 
      {
        if ( document.getElementById(inButton).disabled ) {
          document.getElementById(inButton).classList.add("majorButton");
          document.getElementById(inButton).classList.remove("noHover");
          document.getElementById(inButton).disabled = false;
        }
      }

      function blinkLed()
      {
        document.getElementById("statusLed").classList.remove("green");
        document.getElementById("statusLed").classList.remove("orange");
        document.getElementById("statusLed").classList.add("red");
      }

      function greenLed()
      {
        document.getElementById("statusLed").classList.remove("red");
        document.getElementById("statusLed").classList.remove("orange");
        document.getElementById("statusLed").classList.add("green");
      }

      function orangeLed()
      {
        document.getElementById("statusLed").classList.remove("red");
        document.getElementById("statusLed").classList.remove("green");
        document.getElementById("statusLed").classList.add("orange");
      }

      function changeScreen( scr ) 
      {
        console.log( "INFO  | changeScreen  | input is: "+scr );
        switch( scr ) {
          case screen.main: 
            objectId.set.style.display="none";
            objectId.log.style.display="none";
            objectId.main.style.display="grid";
            break;
          case screen.log:
            objectId.set.style.display="none";
            objectId.log.style.display="grid";
            objectId.main.style.display="none";
            break;
          case screen.settings:
            objectId.set.style.display="grid";
            objectId.log.style.display="none";
            objectId.main.style.display="none";
            break;
          default:
            console.log( "ERROR | changeScreen | oops, fall through default: "+screen.main );
            break;
        }
      }

// when called from the alarm timer the button functions dont work
      function changeState( inState )
      { 
        currentState = inState;
        document.getElementById("z").value = currentState;
        console.log("INFO  | chgSte | chg state to: "+inState );
        switch( inState ) {
          case runStates.off:
          console.log("DEBUG | chgSte | case: runStates.off ::"+inState+":: " );
            objectId.main.style.backgroundColor = c.off; // LightTeal
            disableButton( but.run );
            disableButton( but.off );
          break;
          case runStates.standby:
          console.log("DEBUG | chgSte | case: runStates.standby ::"+inState+":: " );
            objectId.main.style.backgroundColor = c.stby; // Beer
            enableButton( but.run );
            enableButton( but.off );
          break;
          case runStates.run:
          console.log("DEBUG | chgSte | case: runStates.run ::"+inState+":: " );
            objectId.main.style.backgroundColor = c.run; // lightgreen
            disableButton( but.run );
            disableButton( but.reset);
          break;
          case runStates.alarm:
          console.log("DEBUG | chgSte | case: runStates.alarm ::"+inState+":: " );
            objectId.main.style.backgroundColor = c.alarm; // FireEngineRed
            //disableButton( but.stby );
            //disableButton( but.run );
            //disableButton( but.off );
            //enableButton( but.reset );
          break;
          default:
            console.log( "ERROR | chgSte | oops, default::"+inState+":: " );
          break;
        }
      }

      function SetupAudio()
      {
         audio = new Audio("Illustrious.wav");
         audio.loop = true;
         audio.volume = 0.2;
         console.log("DEBUG | setAud | audio src is: " + audio.src );
      }

      // called from multiple places: on startup, when log dismissed,
      // when alarm dismissed and when settings changes have been applied
      // so could come here in any of the run states
      function DisplayMain()
      {
        if ( currentState == runStates.off ) {
          changeState( runStates.off ); // ?? hih, why so
          ClearDisplay();
        }
        //UpdateDisplay();
        changeScreen( screen.main );
      }

      // clear all run values 
      function ResetData()
      {
        console.log("DEBUG | ResetD |" );
        deltaT = deltaD = heading = course = xte = cseError = 0;
        if( DEMO_MODE ) {
            // FIXME once the accumulated offset was moved to an object it never gets cleared
          //latOffAcc = latOffset; lonOffAcc = lonOffset;
          loopCount = 0;
        }
      }

      // update displayed data, do it all at once rather than piecemeal
      function UpdateDisplay()
      {
        console.log("DEBUG | UpDisp |" );
        min = deltaT%60;
        hrAndMin  = Math.trunc(deltaT/60).toString().padStart(2, "0") +":" + min.toString().padStart(2, "0");
        document.getElementById("deltaT").value = hrAndMin;
        document.getElementById("heading").value = heading.toFixed(0)+"°";
        document.getElementById("deltaD").value = deltaD.toPrecision(3)+"nm";
        document.getElementById("course").value = course.toFixed(0)+"°";
        document.getElementById("xteMain").value = xte.toFixed(0)+" m";
        document.getElementById("cseEMain").value = cseError.toFixed(0)+"°";
      }

      function ClearDisplay()
      {
        console.log("DEBUG | ClDisp |" );
        hrAndMin  = 0;
        document.getElementById("deltaT").value = " ";
        document.getElementById("heading").value = " ";
        document.getElementById("deltaD").value = " ";
        document.getElementById("course").value = " ";
        document.getElementById("xteMain").value = " ";
        document.getElementById("cseEMain").value = " ";
      }

      function OutCChg()
      {
        y = document.getElementById("y");
        y.value = document.getElementById("acVar" ).value;
      }

      function OutXChg()
      {
        y2 = document.getElementById("y2");
        y2.value = document.getElementById("xtVar" ).value;
      }

      function OutTChg()
      {
        x = document.getElementById("x");
        x.value = document.getElementById("checkTime" ).value;
      }

      function ShowHelp()
      {
        item = document.getElementById("help");
        if ( item.style.display == "block" ) item.style.display = "none";
        else item.style.display = "block";
      }

      function ShowDemo()
      {
        item = document.getElementById("DemoParms");
        if ( item.style.display == "grid" ) item.style.display = "none";
        else item.style.display = "grid";
      }

      // Settings done button, see if anything has changes then apply it 
      function UpdateSettings()
      {
        // see if anything has been changed
        if ( document.getElementById("checkTime").value != checkTime ) {
          checkTime = Number( document.getElementById("checkTime").value);
          if (( currentState == runStates.run ) | ( currentState == runStates.alarm )) {
            try { 
              window.clearInterval( checkTimer);
              checkTimerCreate--;
              // FIXME move all this to a function/ object  as now done in two places
              if ( currentState == runStates.run ) {
                // set interval timer min*60*1000 msec timer
                timeMsec = checkTime*60*1000;
                if( DEMO_MODE ) timeMsec = checkTime*1000; // fire every checkTime seconds not minutes
                checkTimer = window.setInterval(DoIt, timeMsec);
                checkTimerCreate++;
                if ( checkTimerCreate > 1 ) console.log("ERROR: UpdateSettings Multiple check timers running");
                  checkTimer = window.setInterval(DoIt, timeMsec);
              }
            }
            catch { }
          }
          // timer not running, settings changed before run so leave it alone
          if ( DEMO_MODE ) {
            // Adjust the course offsets as we don't want to be speeding up or slowing down
            //newOffset = oldOffset * checkTime / oldCheckTime;
          }
        }
        if ( document.getElementById("acVar").value != accVar )
          accVar = Number( document.getElementById("acVar").value);
        if ( document.getElementById("xtVar").value != xteVar )
          xteVar = Number( document.getElementById("xtVar").value);
        console.log("DEBUG | UpdSet | checkTime: "+checkTime+" accVar: "+accVar+" xteVar: "+xteVar );
        DisplayMain();
      }
      


      // here's the potatoes

      // Standby button pressed, get current location
      function StandbyMain()
      {
        if (( currentState == runStates.run ) | ( currentState == runStates.alarm )) {  // coming here fron button on run page 
          // Alert to confirm if in run mode, return ( do nothing ) if not confirmed
          if( !confirm("Standby will reset starting location and cancel current run mode" )) {
            return;
          }
          // stop the clock!
          window.clearInterval( checkTimer);
          checkTimerCreate--;
          console.log("INFO  | StbyMain | timer cleared, checkTimerCreate: "+checkTimerCreate );
        }
        if ( currentState == runStates.standby ) {
          console.log("INFO  | StbyMain | state: "+currentState+" reseting data" );
          ResetData();
        }
        changeState( runStates.standby );
        calcOffsets();
        greenLed();
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(locationSuccess, locationError);
          function locationSuccess(position) {
            initialLoc.latitude  = position.coords.latitude;
            initialLoc.longitude = position.coords.longitude;
            if ( DEMO_MODE ) {  // tweak for demo hemisphere
                switch( offsets.accu.hemisp ){
                    case "NE":
                    break;
                    case "SE":
                        initialLoc.latitude  = -position.coords.latitude;
                    break;
                    case "SW":
                        initialLoc.latitude  = -position.coords.latitude;
                        initialLoc.longitude = -position.coords.longitude;
                    break;
                    case "NW":
                        initialLoc.longitude = -position.coords.longitude;
                    break;
                    default:
                      console.log(`ERROR | StbyMain | invalid hemisphere: ${offsets.accu.hemisp} `);
                    break;
                }
            }
            console.log(`INFO  | StbyMain | geo callback ip [ lat ${initialLoc.latitude.toFixed(4)} lon ${initialLoc.longitude.toFixed(4)} ]`);
            // not sure if we should zero these here
            currentLoc.latitude = initialLoc.latitude;
            currentLoc.longitude = initialLoc.longitude;
            UpdateDisplay();
            LogEntry( initialLoc );
          }
          function locationError(err) {
            // we come here if browser / load method doesn't allow geolocation, first call to API is when going into standby
            objectId.main.style.backgroundColor = c.err;  // Yellow
            console.warn('ERROR( | StbyMain | ' + err.code + '): ' + err.message);
            document.getElementById("z").value = 'ERROR(' + err.code + '): ' + err.message;
          }
        } else {
          errStr = "Geolocation is not supported by this browser.";
          console.log( "ERROR | StbyMain | "+errStr );
          document.getElementById("z").value = 'ERROR(' + errStr + '): ' + err.message;
          // should bomb out here as not going to work at all
        }
        console.log("DEBUG | StbyMain | function exit");
      }

      // Run button pressed, start timer
      // This is when we become active, only need heading for now
      function RunMain()
      {
        // on phone there is quite a delay here resulting in multiple presses of the run button and disasterous results
        disableButton( but.run );
        orangeLed();
        // FIXME spin the cursor until callback? 
        // do something to prevent user input while waiting for geo-callback
        if (navigator.geolocation) { 
          navigator.geolocation.getCurrentPosition(locationSuccess, locationError);
          function locationSuccess(position) {
            blinkLed();
            currentLoc.latitude = position.coords.latitude;
            currentLoc.longitude = position.coords.longitude;
            if ( DEMO_MODE ) {
              switch( offsets.accu.hemisp ){
                case "NE":
                break;
                case "SE":
                  currentLoc.latitude  = -position.coords.latitude;
                break;
                case "SW":
                  currentLoc.latitude  = -position.coords.latitude;
                  currentLoc.longitude = -position.coords.longitude;
                break;
                case "NW":
                  currentLoc.longitude = -position.coords.longitude;
                break;
                default:
                  console.log(`ERROR | RunMain | invalid hemisphere: ${offsets.accu.hemisp} `);
                break;
              }
              // change the coords, then increment the offset for next time
              // calcOffsets();  // needs to be done earlier
              currentLoc.latitude += offsets.accu.latOffAcc;
              currentLoc.longitude += offsets.accu.lonOffAcc;
              offsets.accu.latOffAcc += testSet.latOffset;
              offsets.accu.lonOffAcc += testSet.lonOffset;
            }
            console.log("DEBUG | RunMain | cp [ lat " +
            currentLoc.latitude.toFixed(4) + " lon " + currentLoc.longitude.toFixed(4) + " ] offset: [ " +
            testSet.latOffset.toFixed(4) + " " + testSet.lonOffset.toFixed(4) + "]  accum: [" +
            offsets.accu.latOffAcc.toFixed(4) + " " + offsets.accu.latOffAcc.toFixed(4) )+ " ]";
            offsets.accu.hemi = hemiFromLoc( initialLoc );
            quadrant = quadFromLoc( initialLoc, currentLoc );
            dAndc = DandCPlane( initialLoc, currentLoc);
            // this clears the latOffAcc etc. and messes up the demo
            //ResetData();
            heading = dAndc.brg;
            dist = dAndc.dist;
            deltaD += dist; 
            console.log(`INFO  | RunMain | cp [ lat${currentLoc.latitude.toFixed(4)} lon:${currentLoc.longitude.toFixed(4)} ] heading:${heading} deltaD:${deltaD} dist:${dist}`);
            document.getElementById("heading").value = heading.toFixed(0)+"°";
            changeState( runStates.run );
            LogEntry( currentLoc );
            // start the clock
            timeMsec = checkTime*60*1000;
            if( DEMO_MODE ) timeMsec = checkTime*1000; // fire every checkTime seconds not minutes
            if( checkTimerCreate < 1 ) {
             checkTimer = window.setInterval(DoIt, timeMsec);
             checkTimerCreate++;
            }
            else {
              // timer already running, it's a logic error
              console.log("ERROR | RunMain | timer already running when Callback in RunMain" );
            }
            if ( checkTimerCreate > 1 ) console.log("ERROR | RunMain | Multiple check timers running");
          }
          function locationError(err) {
            // we come here if browser / load method doesn't allow geolocation, first call to API is when going into standby
            objectId.main.style.backgroundColor = c.err;  // Yellow
            console.warn('ERROR | RunMain | (' + err.code + '): ' + err.message);
            document.getElementById("z").value = 'ERROR(' + err.code + '): ' + err.message;
          }
        } else {
          console.log("ERROR | RunMain | Geolocation is not supported by this browser.");
        }
        console.log("DEBUG | RunMain | function exit");
      } 

      // Stop Tracking and clear all values
      // can call by button from run or standby states
      function OffMain()
      {
        if ( currentState == runStates.run ) {
          // Alert to confirm if stay in run mode, return ( do nothing ) if not confirmed
          if( !confirm("tracking will terminate\n and all parameter reset" )) {
            return;
          }
          // fall through
        }
        changeState( runStates.off );
        orangeLed();
        LogEntry( currentLoc );
        // reset all tracking variables so as to not have random effects
        ResetData();
        LogEntry( currentLoc );
        UpdateDisplay();
        // halt timer if set
          try { window.clearInterval( checkTimer )
            console.log("DEBUG | OffMain | interval timer halted OK");
          }
          catch(err) { 
            console.log("DEBUG | OffMain | catch exception: clearInterval() interval timer not running?? ");
          } // do nothing, means we came back to off mode without running 
      }

      // called by DoIt function if alarm condition exists
      function DisplayAlarm()
      {
        // toggle audio alarm and others?
        if ( audioPlaying == false ) {
          audio.play();
          audioPlaying = true;
        }
        console.log("ALARM | dispAlarm | alarm but.reset is :"+but.reset+":: " );
        enableButton( but.reset );
        // these throw an exception
            //disableButton( but.stby );
            //disableButton( but.run );
            //disableButton( but.off );
        // if we are on the log or settings 
        //changeScreen( screen.main );
        changeState( runStates.alarm );
        document.getElementById("z").value = currentState;
        alarmBg = true;
        // flash background  but only one timer please
        try {
          if ( flashTimerCreated == false ) {
            flashTimer = window.setInterval(ToggleScreen, 1000);
            flashTimerCreated = true;
          console.log("flash timer created" );
          console.log ("DEBUG | dispAlarm | created alarm timer " );
          } else {
          console.log ("ERROR | dispAlarm | flash timer already created" );
          }
        }
        catch(err) {  
          console.log ("ERROR | dispAlarm | error creating alarm timer " );
        }
      }

      function ToggleScreen()
      {
         if ( alarmBg == true ) {
           objectId.main.style.backgroundColor = c.stby; // Beer
         }
         else {
           objectId.main.style.backgroundColor = c.alarm; // FireEngineRed
         }
         alarmBg = !alarmBg;
      }

      // Reset will the alarm condition, it may fire again on the next check. 
      function Reset()
      {
        if ( audioPlaying == true ) {
          audio.pause();
          audioPlaying = false;
          console.log("DEBUG | Reset  | Audio paused" );
        }
        else { 
            console.log("ERROR | Reset  | no audio playing to pause ???" );
        }
        // stop the screen flashing 
        try {
          if ( flashTimerCreated == true ) {
            window.clearInterval( flashTimer );
            flashTimerCreated = false;
            console.log("DEBUG | Reset  | flash timer cleared ftC = false" );
          }
          else { 
            console.log("ERROR | Reset  | no flash timer to clear ???" );
          }
        }
        catch ( err ){
                // wtf? should have been there
                flashTimerCreated = false;
                console.log("ERROR  | Reset  | exception clearing flash timer" );
        }
        alarmBg = true;
        // disable the reset button and enable the rest 
        //disableButton( but.reset);
        changeState( runStates.run );
      }

      // From button of Main or Alarm divs
      function DisplayLog()
      {
        changeScreen( screen.log );
      }

      // From button of Main div
      function DisplaySettings()
      {
        // copy current settings values to display objects both input & output
        document.getElementById("checkTime").value = checkTime;
        document.getElementById("x").value         = checkTime;
        document.getElementById("acVar").value     = accVar;
        document.getElementById("y").value         = accVar;
        document.getElementById("xtVar").value     = xteVar;
        document.getElementById("y2").value        = xteVar;

              // FIXME hmm, why heading alone here ??
        document.getElementById("heading").value = heading.toFixed(0)+"°";

        changeScreen( screen.settings );
      }

      // And now for the meat

      // Timer fires, get location calc course & distance
      // could also be on alt screen when update occurs
      function DoIt()
      {
        // get current location
        if (navigator.geolocation) {  
          // ripple
          previousLoc.latitude = currentLoc.latitude;
          previousLoc.longitude = currentLoc.longitude;
          navigator.geolocation.getCurrentPosition(function(position) {
            currentLoc.latitude = position.coords.latitude;
            currentLoc.longitude = position.coords.longitude;
            console.log(`-----------------------------------------------------------------------------`);
            if ( DEMO_MODE ){
              switch( offsets.accu.hemisp ){
                case "NE":
                break;
                case "SE":
                  currentLoc.latitude  = -position.coords.latitude;
                break;
                case "SW":
                  currentLoc.latitude  = -position.coords.latitude;
                  currentLoc.longitude = -position.coords.longitude;
                break;
                case "NW":
                  currentLoc.longitude = -position.coords.longitude;
                break;
                default:
                  console.log(`ERROR | DoItCb | invalid hemisphere: ${offsets.accu.hemisp} `);
                break;
              }
              console.log("DEBUG | DoItCb | hemisphere: "+offsets.accu.hemisp+" quadrant: "+quadrant );
              currentLoc.latitude  += offsets.accu.latOffAcc;
              currentLoc.longitude += offsets.accu.lonOffAcc;
              loopCount++;
              if (loopCount > offsets.accu.loopCount ) {
                testSet = offsets.subs;
              }
              console.log(`DEBUG | DoItCb | DEMO MODE loop ${loopCount}` +
                          ` Acc[${offsets.accu.latOffAcc.toPrecision(4)}:${offsets.accu.lonOffAcc.toPrecision(4)}]`+
                          ` [${offsets.init.latOffset.toPrecision(4)}:${offsets.init.lonOffset.toPrecision(4)}]`);
              offsets.accu.latOffAcc += testSet.latOffset;
              offsets.accu.lonOffAcc += testSet.lonOffset;
            }            
            console.log(`INFO  | DoItCb | cp [ lat: ${currentLoc.latitude.toFixed(4)} lon: ${currentLoc.longitude.toFixed(4)} ]`);
            // calc distance and course from previous position point
            dAndC = DandCPlane( previousLoc, currentLoc );
            dist = dAndC.dist;
            deltaD += dist; 
            deltaT += checkTime; // this could drift if user plays with check time
            course = dAndC.brg;
            console.log(`INFO  | DoItCb | course: ${course.toFixed(0)} deltaT: ${deltaT} deltaD: ${deltaD.toPrecision(3)} dr: ${dist}`);

            // calc expected posn, use heading as set when changed to run mode and previous loc
            estLoc = CalcEstPosition( initialLoc, deltaD, heading );
            console.log(`INFO  | DoItCb | ep [ lat: ${estLoc.latitude.toFixed(4)} lon: ${estLoc.longitude.toFixed(4)} ]`);

            // calc XTE and Cse Error
            dAndC2 = DandCPlane( estLoc, currentLoc );
            xte = dAndC2.dist*1800; // distance from expected location
            cseError = Math.abs( heading - course );   
            // FIXME, want to know which direction, port or stbd
            console.log(`INFO  | DoItCb | xte: ${xte} (${xteVar}) cseError: ${cseError} (${accVar})`);
            UpdateDisplay();
            if (( cseError > accVar ) | ( xte > xteVar )) { // are we off course?
              console.log(`ALARM | DoItCb | xteVar: ${xteVar} accVar: ${accVar}`);
              DisplayAlarm();
            } 
            else {
              // has there been an alarm condition and now there is not?
              if ( currentState == runStates.alarm ) {
                currentState = runStates.run;
              }
            }
            LogEntry( currentLoc );
            // reset timer -- no need, its a recurring interval timer
          });
        } else {
          console.log("ERROR | DoIt    | Geolocation is not supported by this browser.");
        }
        console.log("DEBUG | DoIt    | function exit");
      }


      // short distances, use trig after converting to Minutes of arc
      function DandCPlane( pos1, pos2 )
      {
        console.log(`INFO  | D&C    | p1 [ lat: ${pos1.latitude.toFixed(4)} lon: ${pos1.longitude.toFixed(4)} ] p2 [ lat: ${pos2.latitude.toFixed(4)} lon: ${pos2.longitude.toFixed(4)} ]`);
        // parallel sailing adjust from lattitude when converting form arc Minutes to Nm
        adj = cosd( pos1.latitude );
        // this will fail if crossing the prime or antimeridian
        dlonNm = ( pos2.longitude - pos1.longitude) * 60 * adj; 
        dlatNm = ( pos2.latitude - pos1.latitude ) * 60;
        distanceNm = Math.sqrt( dlatNm*dlatNm + dlonNm*dlonNm ); 
        bearing = Math.acos(dlatNm/distanceNm)/dtr;
        // calc using other methods 
        bearing2 = Math.asin(dlonNm/distanceNm)/dtr;
        // OR get bearing first the distance
        bearing3 = atand( dlatNm / dlonNm );
        dist2 = dlonNm / sind( bearing3 );
        dist3 = dlatNm / cosd( bearing3 );

        // adjust bearing for quadrant
        if ( quadrant > 2 ) bearing = 360 - bearing;
        console.log(`INFO  | D&C    | All NM ->( dlon: ${dlonNm.toFixed(4)} dlat: ${dlatNm.toFixed(4)} ) Latadj: ${adj.toFixed(4)}
               | brg: ${bearing.toFixed(0)} brg2: ${bearing2.toFixed(0)} brg3: ${bearing2.toFixed(0)}
               | dist: ${distanceNm.toFixed(2)} dist2: ${dist2.toFixed(2)} dist3: ${dist3.toFixed(2)}`);
        return { dist: distanceNm, brg: bearing }
      }

      // est where we should have been after this distance
      function CalcEstPosition( pos1, distNm, berg )
      {
        const pos2 = { latitude: 0, longitude: 0 };
        // FIXME need to see if we go around the horn either way
        dist = distNm / 60;
        dlat = dist * cosd( berg );
        departure = dist * sind( berg );
        dlon = departure / cosd( pos1.latitude )  // should be m-lat but close enough
        // cos & sin return correct sign (+/-) , so just add
        pos2.latitude = pos1.latitude + dlat;
        pos2.longitude = pos1.longitude + dlon;
        console.log(`INFO  | CEP    | pp [ lat: ${pos1.latitude.toFixed(4)} lon: ${pos1.longitude.toFixed(4)} ] distNm: ${distNm.toFixed(2)} brg: ${berg.toFixed(0)}`);
        console.log(`INFO  | CEP    | ep [ lat: ${pos2.latitude.toFixed(4)} lon: ${pos2.longitude.toFixed(4)} ] brg type: ${typeof(berg)} ]`);
        return( pos2 );
      }


//Auxiliary functions

//sine in degrees
function sind(x)
{
return Math.sin(dtr*x);
}

//cosine in degrees
function cosd(x)
{
return Math.cos(dtr*x);
}

//arctangent in degrees
function atand(x)
{
return Math.atan(x)/dtr;
}

// these 2 used in runMain, when setting up 
function hemiFromLoc( pos )
{
  // FIXME this is only North&East - no seems to be ok for all, why? 
  if ( pos.latitude > 0 ) {
      if ( pos.longitude > 0 ) {
          hemi = "NE"; // NE
      } else {
          hemi = "NW"; // NW
      }
  } else {
      if ( pos.longitude > 0 ) {
          hemi = "SE"; // SE
      } else {
          hemi = "SW"; // SW
      }
  }
  return hemi;
}

function quadFromLoc( pos1, pos2 )
{
  if ( pos1.latitude > pos2.latitude ) { gNorth = false; }
  else { gNorth = true; }
  if ( pos1.longitude > pos2.longitude ) { gEast = false; }
  else { gEast = true; }

  if ( gNorth ) {
    if ( gEast ) { quad = 1; } // NE 
    else { quad = 4; }         // NW
  }
  else {
    if ( gEast ) { quad = 2; } // SE
    else { quad = 3; }         // SW
  }
  return quad;
}

// Logging stuff - well formatted logs are easy to understand

function LogEntry( loc )
{
        // Time runtime timeof day  HH:MM
        timeStr = new Date().toLocaleTimeString([], { hour: '2-digit', minute: "2-digit", hour12: false });
        minEl = deltaT%60;
        timeEl  = Math.trunc(deltaT/60).toString().padStart(2, " ") +":" + minEl.toString().padStart(2, "0");
        // Distance MM.mm or MMM.m
        if ( deltaD < 100 ) {
          distEl = deltaD.toFixed(2).toString().padStart(5, " " );
        } else {
          distEl = deltaD.toFixed(1).toString().padStart(5, " " );
        }
        // Lat/Lon DDD.dddd 
        lat = PadNumber(loc.latitude, 4, 4);
        lon = PadNumber(loc.longitude, 4, 4);
        //console.log( "|" + lat +"|"+ lon +"|" );
        // hdg / cse  DDD    
        hdg = PadNumber(heading, 3, 0);
        cse = PadNumber(course, 3, 0 );
        //console.log( "hdg:" + hdg +"cse:" +  cse );
        // dont use `${timeStr}`  as strings get turned back into numbers 
        const line1 = "|"+timeStr +"|Lat:"+lat+"|hdg:"+hdg+"|dt:"+timeEl+"|xte:"+xte.toFixed().toString().padStart(3, " ")+"|\n" +
                      "|"+currentState+"|Lon:"+lon+"|cse:"+cse+"|dd:"+distEl+"| ce:"+cseError.toFixed().toString().padStart(3, " ")+"|\n" +
                      "|-----|-------------|-------|--------|-------|\n";
        
        // prepend message so most recent at top
        var logText = document.getElementById('logTextArea');
        curLog = line1 + logText.value;
        logText.value = curLog;

        // and, log to screen
        const statusBar1 = currentState+" "+timeStr;
        document.getElementById("z").value = statusBar1;
        const statusBar2 = "Lat "+lat;
        document.getElementById("z1").value = statusBar2;
        const statusBar3 = "Lon "+lon;
        document.getElementById("z2").value = statusBar3;
}

function ClearLog()
{
  var logText = document.getElementById('logTextArea');
  logText.value = "";
}

function WriteLogEntry( loc )
{
  var logEntry = LogEntry( loc );
  // prepend message so most recent at top
  var logText = document.getElementById('logTextArea');
  curLog = logEntry + logText.value;
  logText.value = curLog;
}

//  format the passed in num with pre digits before the decimal ( in padding ) and places after 
function PadNumber( num, pre, places )
{
  switch(places) {
    case 0: shift = 0; break;
    case 1: shift = 10; break;
    case 2: shift = 100; break;
    case 3: shift = 1000; break;
    case 4: shift = 10000; break;
    case 5: shift = 100000; break;
    default: shift = 100; break;
  }
  iPart = Math.trunc(num);
  fPart = Math.abs( Math.trunc(( num - iPart ) * shift)); 
  fPartStr = fPart.toString();
  fPartPadded = fPartStr.padStart(places, "0");

  iPartStr = iPart.toString();
  iPartPadded = iPartStr.padStart(pre, " ");
  // recombine and sent it home
  // FIXME this test was failing with -ve numbers so abs the fraction part, why test ?
  if( fPart > 0 ) outStr = iPartPadded + "." + fPartPadded;
  else outStr = iPartPadded;
  return( outStr );
}

</script>

</head>

<body bgcolor="#7dfdfe" onload="StartApp()">
  
<h1 id="versionString">Offcourse Alarm</h1> 

<!-- <div id="MainPage" width=400px > -->
<div id="MainPage">
  <div><button onclick="RunMain()"     class="majorButton" id="RunButton">&nbsp;&nbsp;Run&nbsp;&nbsp;</button></div>
  <div><button onclick="StandbyMain()" class="majorButton" id="StandbyButton">&nbsp;Stby&nbsp;</button></div>
  <div><button onclick="OffMain()"     class="majorButton" id="OffButton">&nbsp;OFF&nbsp;</button></div>
  <div class="rowbox" ><div class="red led" id="statusLed" ></div><div><output id="z"  class="statusBar"></div></div>
  <div><output id="z1" class="statusBar"></div>
  <div><output id="z2" class="statusBar"></div>
  <div><legend>ΔTime  </legend></div>
  <div><legend>Heading</legend></div>
  <div><legend>XTE    </legend></div>
  <div><output id="deltaT"  class="outData"></div>
  <div align="center"><output id="heading" class="outData"></div>
  <div align="center"><output id="xteMain" class="outData"></div>
  <div><legend>ΔDistance</legend></div>
  <div><legend>Course   </legend></div>
  <div><legend>CseE     </legend></div>
  <div><output id="deltaD"   class="outData"></div>
  <div align="center"><output id="course"   class="outData"></div>
  <div align="center"><output id="cseEMain" class="outData"></div>
  <div><button onclick="DisplaySettings()" class="minorButton">Settings</button></div>
  <div><button onclick="DisplayLog()"      class="minorButton">Log</button></div>
  <div><button onclick="Reset()"           class="majorButton" id="ResetButton">Reset</button></div>
</div>

<div id="Settings">
    <div class="setTxt" ><legend class="settings" >Settings</legend></div>
    <div class="setTxt" ><legend class="settings" >Check duration (minutes)</legend></div>
    <div><input type="range" id="checkTime" name="a" value="5" min="5" max="60" step="5" oninput="OutTChg()"></div>
    <div><output id="x" class="setOut" value="0"></div>
    <div class="setTxt" ><legend class="settings" >Off Course Limit (Degrees)</legend></div>
    <div><input type="range" id="acVar" value="5" min="5" max="60" step="5" oninput="OutCChg()"></div>
    <div><output id="y" class="setOut"></div>
    <div class="setTxt" ><legend class="settings" >Cross track Limit (metres)</legend></div>
    <div><input type="range" id="xtVar" value="500" min="200" max="1000" step="50" oninput="OutXChg()"></div>
    <div><output id="y2" class="setOut"></div>
    <div id="returnButton"><button onclick="UpdateSettings()" class="minorButton2">Done</button></div>
    <div class="rowbox"  id="minorButtons">
      <div><button onclick="ShowDemo()" class="minorButton2">Demo</button></div>
      <div><button onclick="ShowHelp()" class="minorButton2">Help</button></div>
    </div>
</div>
<div id="Log">
  <div id="logtxt"><textarea id="logTextArea" rows="20" cols="46"></textarea></div>
  <div class="rowbox"  id="minorButtons">
    <div id="logbut"><button onclick="DisplayMain()" class="minorButton2">Done</button></div>
    <div id="logbut"><button onclick="ClearLog()"    class="minorButton2">Clear</button></div>
  </div>
</div>
<div id="DemoParms" style="display: none;">
  <div>init  CSE:</div>
  <div><input type="text" id="initcse" name="initcse" size="3"></div>
  <div>SPD:</div>
  <div><input type="text" id="initspd" name="initspd" size="3"></div>
  <div>DUR:</div>
  <div><input type="text" id="initdur" name="initdur" size="3"></div>
  <div>subs CSE:</div>
  <div><input type="text" id="subscse" name="subscse" size="3"></div>
  <div>SPD:</div>
  <div><input type="text" id="subsspd" name="subsspd" size="3"></div>
  <div>HEMI:</div>
  <div><input type="text" id="hemisp" name="hemisp" size="3"></div>
  <div>DEMO:</div>
  <div><input type="checkbox" id="demoMode" checked="true"></div>
</div>
<div id="help" style="display: block;">
<ol>
  <li>Press <b>Stby</b> to capture an initial position.</li>
  <li>Get your vessel on to the desired heading, trim etc.</li>
  <li>review <b>Settings</b> for desired checking interval and off-course bearing and xte limit.</li>
  <li>press <b>Run</b> to capture the current position. A heading will be calculated and a timer started.</li>
  <li>When the timer expires  the current position will be updated and the course checked against the heading from earlier.</li>
  <li>If am alarm condition exists, the screen will flash and the klaxon will sound.</li>
  <li><b>Reset</b> the alarm will stop the noise BUT if the alarm condition still exists it will trigger again next check.</li>
  <li>You can either change <b>Settings</b>, go to <b>Stby</b> or turn <b>OFF</b></li>
</ol>
</div>
</body></html>
